# Boxer Generator
> **Created By:** Hasnaath Ali

# Contents
* [ Project Objective ](#obj)
* [ Project Planning ](#plans)
* [ Front End Design ](#FED)
* [ Testing and Automation](#TA)
* [ Future Development](#FD)

<a name="obj"></a>
## 1. Project Objective
In this project four service was created to containerise the boxer generator application. Service one 
renders the Jinja2 templates needed to interact with the application. In other words, service one is 
seen as the front-end-api which is responsible for communicating with the other 3 services and rendering 
an HTML template. Service two and three are used to generate objects. In this scenario of the boxer 
generator, service two generates a random boxer name and a random integer between 0-50 for its stamina. 
Service three however only generates a number between 0-50 which represents the boxer’s strength. 
Service four uses the results generated by service two and three to come out with how skilled the boxer 
is. So, if the boxer was Gennady Golovkin with a stamina of 35 and a strength of 48; service four 
determines that his level will be World Class which will be viewed in the front-end.

Requirements | Information
------------ | -------------
Kanban Board | Trello board for project tracking
Cloud Server | GCP for Virtual Machines
Feature Branching | Git is used for the Version Control system
Containerisation | Docker is used for the containerisation of services
Orchestration | Docker Swarm is used to replicate containers across multiple VM's
Reverse Proxy | NGINX allows the user to access the project using a reverse proxy server
CI Server | Jenkins is used for continuous integration
Webhooks | Triggers a Jenkins redeployment if the code gets changed
Configuration | Ansible is used for the configuration management and application-deployment


<a name="plans"></a>
## 2. Project Planning
Perhaps one of the key aspects of the project as the planning can inform the developer on 
what is there to implement, the user interaction with the application and what risks you may 
be faced with. But mainly a developer must keep track of what they are doing by using a 
project tracker of some sort.

### Project Tracker ###
There are many project management tools which could have been used to track the progress of 
the project; main ones being Jira and the Trello Board. This keeps the developer on track on
what needs to be completed and what is still remaining to complete. In this project the Trello
Board was used as seen in the image below.

![Trello](https://user-images.githubusercontent.com/101266487/168450738-986fcf7b-17a4-4981-81e1-6ae2338bd52f.JPG)

### Risk Assessment ###
When developing an application that requires user interaction, several issues which must be
addressed regarding the user’s privacy. A risk assessment had to be done for this project so 
some action could be taken to counteract any risk that could have cropped at anytime. A risk 
assessment also gives the developer a chance to perhaps implement any measures which could be taken 
before any risks actually happen. 

![Risk Assessment](https://user-images.githubusercontent.com/101266487/168496863-e0a7f272-f0fd-4ec5-8780-02afdead9d6d.JPG)

### Functional Requirements & User Stories ###
The functional requirements are how the application will function and highlighting all the 
features that will included in the application. Also, the functional requirements are primarily 
based at the use cases (the user, system functional requirements, goals) for this project and will 
guarantee a fully purposeful application.

![Functional requirements](https://user-images.githubusercontent.com/101266487/168497215-0b45eac8-b9b9-45ad-b1fc-3260240035af.JPG)

A user story is used to see the end goal which is expressed in the user’s perspective. Furthermore, a user story works well with 
the functional requirements stated above as it would give a developer whatmust be required for this project to be a success. A few
user stories are listed below:
- As a user I want to view the boxer's name so that I can see which boxer has been selected
- As a user I want to view the boxer's strength so that I can see the strength of the boxer
- As a user I want to view the boxer's stamina so that I can see the stamina of the boxer
- As a user I want to view the boxer's stats so that I can see what level my boxer is at
- As a user I want to click a button so that it generates a new boxer

### CI Pipeline ###
CI commonly known as Continuous Integration is the automated integration of code from the contributors into a project. The purpose 
of the CI pipeline is to allow developers to integrate newly generated code easily and frequently. This is achieved through the 
use of automated testing tools to check if the code is correct before fully integrating it. So, in this instance of the CI pipeline 
for this project, (in the picture below) code produced on the local machine by Python3 would get pushed to GitHub, which in turn is
pushed into Jenkins. Jenkins then automatically runs tests which produces a report. Since all the services in this project is 
containerised using docker, the images are pushed to Docker Hub. The images created are pushed to Ansible for the building orchestration. 
Continuous deployment by multiple replica’s created across Docker Swarm means that the application uses four VM’s where three VM’s are 
used for deployment.

![CI Pipeline2](https://user-images.githubusercontent.com/101266487/168499507-9c12c862-c01a-45b2-a544-1c38e3d66b7e.jpg)

<a name="FED"></a>
## Front End Design
The front-end of the application was mainly built on very simple HTML code on visual studio. The aim is to produce a simple but 
working application with a navigation bar for user to navigate around the URL. When first loading the boxing application, the user will 
be met with the image below. 

![home page](https://user-images.githubusercontent.com/101266487/168595952-5faaa314-9846-4274-bd32-1e3e45be5599.JPG)

As seen above, the users are asked to select generator from the tab above which in turn leads to the boxer generator. This is where the
users can generate boxers name, stamina, strength, and the overall boxing level which is given in the sentence. Furthermore, the users can
also see a new boxer button, where on click produces a new boxer with different stats as seen below.

![ggg](https://user-images.githubusercontent.com/101266487/168598555-8a3c4fe8-f803-4730-ad20-3f4daf470efa.JPG)

![Floyd](https://user-images.githubusercontent.com/101266487/168598646-cbae395d-1c20-4342-8975-b7ef20adf186.JPG)

![manny](https://user-images.githubusercontent.com/101266487/168598668-e7da9fe2-c4f9-454d-a19f-75d6e062fc74.JPG)

![MA](https://user-images.githubusercontent.com/101266487/168598697-054e5431-821f-4dcb-8f89-53d4c88d705f.JPG)

![tyson](https://user-images.githubusercontent.com/101266487/168598718-1cb3ee59-790f-4de4-a9e4-8468b99bb0c9.JPG)

As seen above, all boxers have different stats which determines the level they are. This is done by using the stamina and strength number 
from service 2 & 3. Service 4 combines both numbers together to get one number to give it the appropriate level. For example, in the picture 
above it can be seen that Manny Pacquiao has a stamina of 18 and strength of 49. When combining the two numbers together, you get 67 which falls
in Level[4] which is between 60 and 75. Therefore, giving the boxer a fighting level of Professional. The front-end api displays this as a 
sentence which is seen above the new boxer button.

<a name="TA"></a>
## Testing and Automation
To test the python routes, pytest was used to ensure the back-end of my application was functional. This tests all of the written code to see if
there are any issues that may need correcting. Using pytest --cov, this allows us to show the coverage which can be seen in the image below.
Furthermore, assertions are used to ensure the correct output is being used and the request/request_mock is used to simulate the interactions 
between the services. 

Service 1:

![service1](https://user-images.githubusercontent.com/101266487/168610627-e3f5739f-65e3-421f-beb8-1aac46384b0f.JPG)

Service 2:

![service2](https://user-images.githubusercontent.com/101266487/168610758-106d6396-dabd-41ac-b898-28540854e958.JPG)

Service 3:

![service3](https://user-images.githubusercontent.com/101266487/168610799-9e38070c-9f33-4cb9-af67-38aef038e193.JPG)

Service 4:

![service4](https://user-images.githubusercontent.com/101266487/168610838-16ee7b03-2278-4025-ae1b-51438ce33c96.JPG)

### Jenkins ###
Jenkins was used as a continuous deployment, where if the application had a change in code, the user would not experience any downtime at all.
In order for this to occur, a combination of tools was used which have been named in the requirements table in the Project Objective. At first 
the Jenkins goes through stage 1 which is testing stage. This stage is showing the testing of the four services which has been done manually above.
This can also be seen in the Jenkins console output which is shown in the image shown below.

![testing in jenkins](https://user-images.githubusercontent.com/101266487/168638005-3c6e03c8-b8ff-411a-a0c2-3f4cec0b8831.JPG)

The second stage Jenkins goes through is the docker stage. This is where Jenkins starts to build images for all four services and the images are
then pushed to Dockerhub. Dockerhub username and password has environment variables which has already been set beforehand therefore Jenkins can 
login and push the images up to our Dockerhub account. 

The next stage Jenkins goes through is the deployment stage. This is where the application is deployed by using Docker-Swarm whilst using Ansible 
through the use of its playbook and inventory and the other main.yml files in the swarm-manager and swarm-worker files. Ansible configures the
swarm-manager and swarm-worker so that the application is ready for deployment. The Ansible Playbook first install docker on all swarm machines, 
then it initialises a swarm on the manager node and uses the Ansible docker stack module to deploy the application. Finally, the last role for the
Ansible playbook is to add the worker node to the swarm.

When the whole stage is complete and is a success. The build will show a green tick as shown below.
![pipeline2](https://user-images.githubusercontent.com/101266487/168639232-8111e53c-b98d-4726-b1a4-03d50bf708be.JPG)
![success](https://user-images.githubusercontent.com/101266487/168639298-3bb286b8-f233-4e83-b58a-8b35d2198f28.JPG)

The stage will come across as green if your whole stage is a success as seen in the image below. However, if one stage fails, Jenkins will show 
what stage failed by showing it in red. 
![pipeline](https://user-images.githubusercontent.com/101266487/168639394-eb9bf7ba-4347-4b2e-864a-1bcbdacfd8aa.JPG)

The last aspect of the deployment is the use of a Webhook. This is where if the code is changed from VS and is then pushed and then 
committed. The Jenkins pipeline since linked to the github branch, will automatically run a new build.

<a name="FD"></a>
## Future Development
The next phase for this application to go through is the following
-	Creating a database to store all generated boxers
-	Better UI design could be used instead of making the page look plain and simple
-	A more welcoming home page with details of how the application works
The future development of the application above is key if the application was used in an actual fighting game for example. As the database would 
store generated boxer’s and their stats to go up against an upcoming opponent.	Furthermore, better UI graphics would make the application more 
appealing to look at.


## Acknowledgements
* 22MarEnable1 Cohort
* QA Community

## Authors
**Hasnaath Ali**
